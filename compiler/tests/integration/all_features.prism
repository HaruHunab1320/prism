// Comprehensive test of all Prism language features

// 1. Basic Types and Confidence Values
let int_val = 42;                 // Integer
let float_val = 3.14;            // Float
let string_val = "hello";        // String
let bool_val = true;             // Boolean
let conf_val ~0.9 = 0.8;         // Value with confidence

// 2. Arrays and Collections
let numbers = [1, 2, 3] ~0.95;   // Array with confidence
let mixed = [1, "two", 3.0];     // Heterogeneous array
let nested = [[1, 2], [3, 4]];   // Nested array

// 3. Functions with Confidence
fn add(x: float, y: float) -> float ~0.95 {
    return x + y;
}

fn multiply(x, y) {  // Type inference
    return x * y ~> 0.9;  // Confidence flow
}

// 4. Generics and Traits
trait Measurable<T> {
    fn measure(self) -> float ~0.8;
    fn combine(self, other: T) -> T ~0.9;
}

struct DataPoint<T> {
    value: T,
    confidence: float,
}

impl<T> Measurable<T> for DataPoint<T> {
    fn measure(self) -> float ~0.8 {
        return self.confidence;
    }
    
    fn combine(self, other: DataPoint<T>) -> DataPoint<T> ~0.9 {
        return DataPoint {
            value: other.value,
            confidence: self.confidence * other.confidence,
        };
    }
}

// 5. Pattern Matching
fn match_value<T>(value: T) ~0.9 {
    match value {
        x if typeof(x) == "integer" => {
            return x * 2;
        },
        x if typeof(x) == "float" => {
            return x * 2.0;
        },
        _ => {
            return value;
        }
    }
}

// 6. Error Handling
fn divide(x: float, y: float) -> float ~0.9 {
    try {
        if y == 0.0 {
            throw error("Division by zero", confidence: 0.99);
        }
        return x / y;
    } catch e {
        print("Error: " + e.message);
        return 0.0 ~> 0.1;  // Low confidence fallback
    }
}

// 7. Modules and Imports
module Math {
    export fn square(x: float) -> float ~0.99 {
        return x * x;
    }
    
    export fn sqrt(x: float) -> float ~0.95 {
        if x < 0.0 {
            throw error("Negative sqrt", confidence: 0.99);
        }
        return x.sqrt();
    }
}

// 8. Operator Overloading
operator + for DataPoint<T> DataPoint<T> -> DataPoint<T> ~0.9 {
    return DataPoint {
        value: lhs.value + rhs.value,
        confidence: lhs.confidence * rhs.confidence,
    };
}

// 9. Async/Await
async fn fetch_data(url: string) -> string ~0.8 {
    promise ~0.9 "Response from " + url
}

async fn process_data(data: string) -> string ~0.95 {
    await ~0.9 fetch_data("https://api.example.com/" + data)
}

// 10. Macros
macro debug<msg> ~0.9 {
    if confidence($msg) > 0.8 {
        print("High confidence: " + #$msg)
    } else {
        print("Low confidence: " + #$msg)
    }
}

// 11. Context Management
in context DataProcessing {
    verify against sources ["test_data"] {
        let data = [1.0 ~0.9, 2.0 ~0.8, 3.0 ~0.95];
        let processed = data.map(fn(x) { return x * 2; });
        assert(processed.length == 3);
    }
}

// 12. LLM Integration
fn semantic_match(text1: string, text2: string) -> float ~0.9 {
    let similarity = llm.compare(text1, text2);
    return similarity ~> 0.85;
}

// Main test function
async fn main() {
    // Test basic operations
    let sum = add(float_val, 2.0);
    let product = multiply(int_val, 2);
    debug(sum);
    debug(product);
    
    // Test generics and traits
    let point1 = DataPoint { value: 42, confidence: 0.9 };
    let point2 = DataPoint { value: 84, confidence: 0.8 };
    let combined = point1 + point2;
    assert(combined.confidence == 0.72);
    
    // Test pattern matching
    let matched = match_value(42);
    assert(matched == 84);
    
    // Test error handling
    let safe_div = divide(10.0, 2.0);
    let error_div = divide(10.0, 0.0);
    assert(safe_div == 5.0);
    assert(confidence(error_div) == 0.1);
    
    // Test module usage
    let squared = Math.square(4.0);
    let root = Math.sqrt(16.0);
    assert(squared == 16.0);
    assert(root == 4.0);
    
    // Test async operations
    let data = await fetch_data("test");
    let processed = await process_data(data);
    debug(processed);
    
    // Test LLM features
    let text1 = "The weather is nice";
    let text2 = "It's a beautiful day";
    let match_score = semantic_match(text1, text2);
    assert(match_score > 0.7);
    
    print("All tests passed!");
}

// Run tests
main(); 